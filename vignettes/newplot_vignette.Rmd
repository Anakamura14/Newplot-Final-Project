---
title: "Newplot Vignette"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Newplot Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  eval = FALSE,
  message = FALSE,
  warning = FALSE,
  fig.width = 7,
  fig.height = 5
)
```

[![R-CMD-check](https://github.com/Anakamura14/Newplot-Final-Project/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/Anakamura14/Newplot-Final-Project/actions/workflows/R-CMD-check.yaml)

# Newplot Introduction

Newplot is an R package created to make the process of building publication-ready graphics more intuitive and accessible. While ggplot2 remains one of the most powerful and flexible visualization frameworks in R, many users—particularly beginners—struggle with the amount of repeated setup code required to produce polished figures. Tasks such as defining aesthetics, selecting themes, choosing palettes, and handling grouping can feel cumbersome, especially during exploratory work or when preparing multiple plots in a single workflow.

The newplot package was designed to lessen this burden by offering a single, streamlined function (new_plot()) that handles many common visualization steps automatically. The package also includes an interactive Shiny gadget (new_plot_gadget()) that enables users to build visualizations through a graphical interface and automatically generate the corresponding new_plot() code. Together, these tools support smoother learning, faster prototyping, and more efficient analysis.

## Installation

```{r}
devtools::install_github("Anakamura14/Newplot-Final-Project")
library(newplot)
```

## Motivation and Background

The central motivation for newplot is rooted in the common challenges that new and intermediate R users face when navigating the structure and syntax of ggplot2. Even experienced users can find themselves repeatedly writing the same configuration code across projects. By simplifying the interface to ggplot2 and automating key steps—such as palette selection, theme application, and grouping detection—newplot allows users to focus more on interpreting their data rather than wrestling with syntax.

This project also sought to reduce the challenges beginners often encounter when learning core concepts such as aesthetics, color scales, and tidy evaluation. While ggplot2 provides immense flexibility, it does require users to write additional code to achieve a consistent, refined look across plots. Newplot addresses this challenge by providing a stable, predictable foundation for visualization, making ggplot2 more approachable without sacrificing its flexibility.

Alongside its functional improvements, the package is intentionally designed as a teaching tool. The Shiny gadget facilitates interactive visualization building, lowering barriers for students and analysts through guided exploration, while the reproducible code output reinforces best practices and transferable skills.

## Intended Users

Although the package is accessible to users with very little R experience, it is equally advantageous for more advanced analysts who routinely create visualizations as part of their workflow. Students in public health, the social sciences, and statistics can use newplot to become comfortable with fundamental visualization concepts without being overwhelmed by syntax requirements. Analysts benefit from a faster and more structured pathway to clean, consistent graphics, particularly in settings where readability and reproducibility matter. Instructors may also incorporate the package into teaching, using both the function and the gadget to demonstrate how aesthetic decisions translate into code.

## Getting Started

Once the package is loaded, creating a plot requires only a few arguments. A simple scatterplot, for example, can be produced with:

```{r}
new_plot(mtcars, x = "wt", y = "mpg", type = "point")
```

Requiring variable names to be supplied as quoted strings (e.g., "mpg") helps ensure that the function behaves consistently across different contexts, including interactive use, scripted analyses, and package checks. This approach also makes the function easy to use within tidyverse pipelines:

```{r}
mtcars |>
  dplyr::mutate(cyl = factor(cyl)) |>
  new_plot(x = "cyl", y = "mpg", group = "cyl", type = "violin")
```

These examples demonstrate the guiding principle behind newplot: reducing the amount of repeated setup code required for ggplot2 while maintaining clarity and reproducibility.

## The new_plot() Function

The new_plot() function serves as the core of the package. It accepts quoted variable names, validates inputs, determines grouping structure, selects color palettes, and applies themes in a systematic way. By requiring variables to be supplied as strings, the function avoids ambiguity and ensures compatibility across environments, including during package checks.

When a grouping variable is included, new_plot() automatically adjusts the color or fill scales to match the number of groups. If the user specifies a palette, the function uses one of several built-in color sets; if not, it defaults to viridisLite to maintain high readability and support color-blind–friendly gradients. The function currently supports four commonly used plot types: point, line, boxplot, and violin. These options cover a substantial portion of exploratory visualization needs while keeping the interface focused and teachable.

## Basic Usage Examples

```{r}
# Basic point plot
new_plot(mtcars, x = "cyl", y = "mpg", type = "point")
```
```{r}
# Colored scatter plot
new_plot(
  iris,
  x = "Sepal.Length",
  y = "Petal.Length",
  group = "Species",
  type = "point",
  palette = "orange"
)
```

```{r}
# Grouped Boxplot
new_plot(
  mtcars |> dplyr::mutate(cyl = factor(cyl)),
  x = "cyl",
  y = "mpg",
  group = "cyl",
  type = "boxplot",
  palette = "blue"
)
```

```{r}
# Pipe-friendly workflow
mtcars |>
  dplyr::mutate(cyl = factor(cyl)) |>
  new_plot(x = "cyl", y = "mpg", group = "cyl", type = "violin")
```

## Interactive Visualization with Shiny Gadget: new_plot_gadget()

The package’s Shiny gadget expands its usability by providing a fully interactive environment for building plots. Instead of writing code, users choose variables, plot types, themes, and palettes through a sidebar interface. As selections are made, a preview updates instantly, allowing users to see how each choice affects the visualization.

This design makes the gadget valuable for teaching and prototyping. Beginners can learn how different components influence the look of a plot, while more advanced users may appreciate the ability to experiment rapidly. When the user clicks “Done,” the gadget returns both the ggplot object and the exact new_plot() code that reproduces the figure. This reinforces reproducibility and supports integration into downstream scripts.

To launch the gadget:
```{r}
library(newplot)

# Launch the interactive gadget using iris
res <- new_plot_gadget(iris)
res$plot
res$code
```

When run, the gadget opens in a dialog window. Users select x- and y-variables, optionally choose a grouping variable, specify a plot type, adjust labels, and preview the resulting graphic. Pressing “Done” returns both the constructed ggplot object and the exact R code that produced it, bridging the gap between graphical interaction and script-based analysis.

## Proof of Concept: Testing and Validation

During development, the package underwent extensive testing to ensure robust performance across a variety of conditions. Tests verified that the function produced ggplot objects across all supported geometry types, handled grouping correctly, managed palette fallback logic, and generated appropriate error messages when invalid inputs were supplied.

```{r}
# Basic point test
p1 <- new_plot(mtcars, x = "cyl", y = "mpg", type = "point")
inherits(p1, "ggplot")
```

```{r}
# Test violin plot without grouping
p2 <- new_plot(mtcars, x = "cyl", y = "mpg", type = "violin")
inherits(p2, "ggplot")
```

Quoted Inputs:
```{r}
# Quoted
p3 <- new_plot(mtcars, x = "cyl", y = "mpg", type = "line")
inherits(p3, "ggplot")
```

Grouping Tests:
```{r}
# Grouped boxplots
mtcars2 <- mtcars |> dplyr::mutate(cyl = factor(cyl))

p5 <- new_plot(mtcars2, x = "cyl", y = "mpg", group = "cyl", type = "boxplot")
inherits(p5, "ggplot")
```

Error Handling Tests:
```{r}
# Missing column
tryCatch(
  new_plot(mtcars, x = "missing", y = "mpg", type = "point"),
  error = function(e) message("Passed: Missing column error caught")
)
```

Testing Palette Behavior
```{r}
# Custom palette
p6 <- new_plot(
  mtcars2,
  x = "cyl",
  y = "mpg",
  group = "cyl",
  type = "point",
  palette = "orange"
)
inherits(p6, "ggplot")
```

Viridis is used when Palette is not Specified
```{r}
# Test dataset with grouping so colors are created
mtcars2 <- mtcars |> dplyr::mutate(cyl = factor(cyl))

p_v <- new_plot(
  mtcars2,
  x = "cyl",
  y = "mpg",
  group = "cyl",
  type = "point"
)

# Extract actual colors used in the plot
cols_used <- ggplot2::layer_data(p_v)$colour |> unique()

# Compare to viridis palette for 3 groups
cols_expected <- viridisLite::viridis(3)

# Check if they match (order may differ, so we sort)
identical(sort(cols_used), sort(cols_expected))
```

These tests, combined with interactive evaluation through the Shiny gadget, provided strong evidence that the package behaved predictably across scenarios.

## Use Cases 

Newplot supports a variety of real-world workflows. 

Example 1: Exploring Species Differences in the iris Dataset

The iris dataset offers a familiar and intuitive way to demonstrate how new_plot() handles grouped scatterplots. The following visualization examines the relationship between sepal length and petal length across species. This example illustrates how grouping, color assignment, and point plotting work together to reveal meaningful biological patterns.

```{r}
new_plot(
  iris,
  x = "Sepal.Length",
  y = "Petal.Length",
  group = "Species",
  type = "point",
  palette = "orange",
  title = "Petal vs. Sepal Length Across Iris Species"
)
```
This plot offers a clear illustration of species-level differences and highlights the smooth integration of grouping variables within the function.

Example 2: Visualizing Vehicle Performance Trends with mtcars

The mtcars dataset provides an opportunity to explore relationships relevant to applied analytics. In the example below, a scatterplot reveals the strong negative association between vehicle weight and fuel efficiency, allowing users to quickly identify the substantial decline in miles per gallon for heavier cars.

```{r}
new_plot(
  mtcars |> dplyr::mutate(cyl = factor(cyl)),
  x = "wt",
  y = "mpg",
  group = "cyl",
  type = "point",
  palette = "cyan",
  title = "Fuel Efficiency Declines with Vehicle Weight"
)
```
Example 3: Examining Systolic Blood Pressure Across Age Groups

Public health reporting often involves communicating variation in health indicators across demographic categories. The example below uses a small simulated dataset to illustrate how new_plot() can support this type of analysis. Here, systolic blood pressure (SBP) is compared across three age groups using a violin plot, which highlights overall distributional differences and potential disparities.

```{r}
set.seed(123)
ph_data <- data.frame(
age_group = factor(rep(c("18–39", "40–59", "60+"), each = 100)),
systolic_bp = c(
rnorm(100, mean = 118, sd = 10),
rnorm(100, mean = 130, sd = 12),
rnorm(100, mean = 142, sd = 15)
)
)

new_plot(
ph_data,
x = "age_group",
y = "systolic_bp",
type = "violin",
palette = "red",
title = "Systolic Blood Pressure Across Age Groups"
)
```
This visualization reflects patterns commonly encountered in population health data, clearly showing higher blood pressure values in older adults. It also demonstrates how new_plot() handles categorical groupings, applies color palettes automatically, and produces clean, publication-ready distribution plots with minimal code.

## Development Summary

Newplot began as a lightweight wrapper around ggplot2, created to reduce the amount of repeated setup code that users often write. Over time, the function was expanded to include automated palette management, theme specification, grouping detection, and standardized title generation. The integration of the Shiny gadget broadened the package’s purpose, allowing it to serve not only as a workflow tool but also as an instructional resource.

Ensuring R CMD check compatibility played an important role in shaping the final version. Because unquoted variables cannot be resolved during checks, all examples were rewritten to use quoted variable names. Dependencies on shiny and miniUI were moved to the Suggests field, and all function calls were explicitly namespaced using shiny:: and miniUI::, protecting users who do not have those packages installed. These refinements strengthened the package’s stability and ensured predictable behavior across systems.

## Future Work

There are many potential directions for extending the functionality of newplot. Additional geometries—such as histograms, density plots, bar charts, and smoothing layers—could expand the package’s reach into a wider array of exploratory tasks. More advanced thematic controls may also be incorporated, enabling users to apply reusable visual styles or institution-specific formatting standards.

Palette systems could be enhanced with colorblind-friendly defaults, improved contrast checking, or dynamic scaling options that respond more intelligently to the number of groups. The Shiny gadget could evolve to include faceting controls, more customizable aesthetics, image export features, or built-in tutorials that help guide novice users. Continued refinement of internal error handling and automated testing would further strengthen the package and prepare it for broader distribution, including potential submission to CRAN.

## Conclusion

Newplot was developed with the goal of making data visualization in R more approachable, consistent, and efficient. By reducing the amount of repeated setup code required by ggplot2 and automating several aesthetic and structural decisions, the package provides a smoother pathway to clean and interpretable graphics. The Shiny gadget deepens this accessibility by offering an intuitive and exploratory interface that simultaneously reinforces reproducible coding practices.

The project demonstrates how thoughtful tooling can lower barriers for beginners, support teaching and demonstration, and improve the day-to-day workflows of experienced analysts. As visualization needs grow more complex, the foundations laid by newplot offer ample opportunities for future development. Ultimately, the package aims to support users as they build stronger visualization skills and create graphics that communicate data clearly and effectively.

